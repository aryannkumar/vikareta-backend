/**
 * SSO Authentication Routes
 * Secure Cross-Subdomain Single Sign-On with JWT + Refresh Tokens in HttpOnly Cookies
 */

import { Router, Request, Response } from 'express';
import { body, validationResult } from 'express-validator';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { PrismaClient } from '@prisma/client';

import { logger } from '@/utils/logger';
import passport from '@/config/passport';
import { DigiLockerService } from '@/services/digilocker.service';
import { OtpService } from '@/services/otp.service';
import { notificationService } from '@/services/notification.service';

const router = Router();
const prisma = new PrismaClient();


// JWT Configuration
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key';
const REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'your-super-secret-refresh-key';
const ACCESS_TOKEN_EXPIRY = '1h'; // Increased from 15m to 1h to reduce frequent logouts
const REFRESH_TOKEN_EXPIRY = '7d';

// Cookie Configuration
const COOKIE_CONFIG = {
  domain: process.env.NODE_ENV === 'production' ? '.vikareta.com' : undefined,
  path: '/',
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: process.env.NODE_ENV === 'production' ? 'none' as const : 'lax' as const
};

// Log auth routes initialization and key env flags (non-sensitive)
try {
  logger.info('Auth routes initialized', {
    oauthDebug: process.env.OAUTH_DEBUG === 'true',
    frontendUrl: process.env.FRONTEND_URL || null,
    googleCallbackURL: process.env.GOOGLE_CALLBACK_URL || null,
  });
} catch {
  // ignore
}

// Lightweight request logger for auth routes when debugging is enabled
router.use((req, _res, next) => {
  if (process.env.OAUTH_DEBUG === 'true') {
    logger.info('Auth route hit', {
      method: req.method,
      url: req.originalUrl,
      path: req.path,
      query: req.query,
      origin: req.headers.origin,
      host: req.headers.host,
      ua: req.headers['user-agent']
    });
  }
  next();
});



import { refreshTokenStore } from '@/services/refreshTokenStore';
import { cacheService } from '@/services/cache.service';
import crypto from 'crypto';

// Validation middleware
const handleValidationErrors = (req: Request, res: Response, next: any) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      error: {
        code: 'VALIDATION_ERROR',
        message: 'Invalid input data',
        details: errors.array(),
      },
    });
  }
  return next();
};

/**
 * Generate JWT Access Token
 */
function generateAccessToken(user: any) {
  return jwt.sign(
    {
      id: user.id,
      email: user.email,
      role: user.userType,
      userType: user.userType
    },
    JWT_SECRET,
    { expiresIn: ACCESS_TOKEN_EXPIRY }
  );
}

/**
 * Generate Refresh Token
 */
async function generateRefreshToken(user: any) {
  const refreshToken = jwt.sign(
    { id: user.id, email: user.email },
    REFRESH_SECRET,
    { expiresIn: REFRESH_TOKEN_EXPIRY }
  );

  // Store refresh token in a persistent store (Redis) or fallback to memory
  await refreshTokenStore.set(refreshToken, user.id, 7 * 24 * 60 * 60);

  return refreshToken;
}

// CSRF token generation moved to security middleware

/**
 * Set Authentication Cookies
 */
async function setAuthCookies(res: Response, user: any) {
  const accessToken = generateAccessToken(user);
  const refreshToken = await generateRefreshToken(user);
  // CSRF token will be generated by the /csrf-token endpoint when needed

  // Set HttpOnly cookies for tokens with consistent naming
  res.cookie('vikareta_access_token', accessToken, {
    ...COOKIE_CONFIG,
    maxAge: 60 * 60 * 1000 // 1 hour (matches ACCESS_TOKEN_EXPIRY)
  });

  res.cookie('vikareta_refresh_token', refreshToken, {
    ...COOKIE_CONFIG,
    maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
  });

  // Also set legacy cookie names for compatibility during transition
  res.cookie('access_token', accessToken, {
    ...COOKIE_CONFIG,
    maxAge: 60 * 60 * 1000
  });

  res.cookie('refresh_token', refreshToken, {
    ...COOKIE_CONFIG,
    maxAge: 7 * 24 * 60 * 60 * 1000
  });

  // CSRF token is set separately via /csrf-token endpoint
}

/**
 * Clear Authentication Cookies
 */
function clearAuthCookies(res: Response) {
  const expiredConfig = {
    ...COOKIE_CONFIG,
    expires: new Date(0)
  };

  // Clear all possible cookie variations
  res.cookie('vikareta_access_token', '', expiredConfig);
  res.cookie('vikareta_refresh_token', '', expiredConfig);
  res.cookie('access_token', '', expiredConfig);
  res.cookie('refresh_token', '', expiredConfig);
  res.cookie('XSRF-TOKEN', '', { ...expiredConfig, httpOnly: false });
}

/**
 * Middleware: Verify Access Token from Cookie or Authorization Header
 */
function verifyAccessToken(req: Request, res: Response, next: any) {
  // Try to get token from Authorization header first (Bearer token)
  let accessToken = null;
  const authHeader = req.headers.authorization;
  
  if (authHeader && authHeader.startsWith('Bearer ')) {
    accessToken = authHeader.substring(7); // Remove 'Bearer ' prefix
  } else {
    // Try consistent cookie names first, then fallback to legacy
    accessToken = req.cookies.vikareta_access_token || req.cookies.access_token;
  }

  if (!accessToken) {
    return res.status(401).json({
      success: false,
      error: { code: 'NO_TOKEN', message: 'Access token required' }
    });
  }

  try {
    const decoded = jwt.verify(accessToken, JWT_SECRET) as any;
    req.authUser = decoded;
    next();
  } catch (error: any) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        success: false,
        error: { code: 'TOKEN_EXPIRED', message: 'Access token expired' }
      });
    }

    return res.status(401).json({
      success: false,
      error: { code: 'INVALID_TOKEN', message: 'Invalid access token' }
    });
  }
}

// CSRF verification is now handled by global middleware - no duplicate needed

/**
 * POST /auth/register
 * Register new user with SSO cookies
 */
router.post('/register', [
  body('email').isEmail().withMessage('Valid email is required'),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters'),
  body('firstName').trim().isLength({ min: 1 }).withMessage('First name is required'),
  body('lastName').trim().isLength({ min: 1 }).withMessage('Last name is required'),
  body('userType').isIn(['buyer', 'seller', 'both']).withMessage('Invalid user type'),
  handleValidationErrors,
], async (req: Request, res: Response) => {
  try {
    const { email, password, firstName, lastName, userType, businessName, phone, location } = req.body;

    // Check if user already exists
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [
          { email },
          { phone: phone || undefined },
        ],
      },
    });

    if (existingUser) {
      return res.status(409).json({
        success: false,
        error: {
          code: 'USER_EXISTS',
          message: 'User with this email or phone already exists',
        },
      });
    }

    // Hash password
    const passwordHash = await bcrypt.hash(password, 12);

    // Create user
    const user = await prisma.user.create({
      data: {
        email,
        passwordHash,
        firstName,
        lastName,
        businessName,
        phone,
        location,
        userType,
        verificationTier: 'basic',
        isVerified: false,
        isActive: true,
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        businessName: true,
        userType: true,
        verificationTier: true,
        isVerified: true,
        createdAt: true,
      },
    });

  // Set authentication cookies
  await setAuthCookies(res, user);

    // Create user response with name field
    const userResponse = {
      ...user,
      name: `${user.firstName} ${user.lastName}`,
      role: user.userType,
      verified: user.isVerified
    };

    logger.info('SSO: User registered successfully:', { userId: user.id, email: user.email });

    return res.status(201).json({
      success: true,
      user: userResponse,
      message: 'User registered successfully',
    });
  } catch (error) {
    logger.error('SSO: Registration error:', error);
    return res.status(500).json({
      success: false,
      error: {
        code: 'REGISTRATION_FAILED',
        message: 'Failed to register user',
      },
    });
  }
});

/**
 * POST /auth/login
 * Login with username/password and set SSO cookies
 */
router.post('/login', [
  body('email').isEmail().withMessage('Valid email is required'),
  body('password').notEmpty().withMessage('Password is required'),
  handleValidationErrors,
], async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;

    // Find user
    const user = await prisma.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        passwordHash: true,
        firstName: true,
        lastName: true,
        businessName: true,
        userType: true,
        verificationTier: true,
        isVerified: true,
        createdAt: true,
      },
    });

    if (!user || !user.passwordHash) {
      return res.status(401).json({
        success: false,
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password',
        },
      });
    }

    // Verify password
    const isValidPassword = await bcrypt.compare(password, user.passwordHash);
    if (!isValidPassword) {
      return res.status(401).json({
        success: false,
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password',
        },
      });
    }

  // Set authentication cookies
  await setAuthCookies(res, user);

    // Create user response with name field
    const userResponse = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      name: `${user.firstName} ${user.lastName}`,
      businessName: user.businessName,
      role: user.userType,
      userType: user.userType,
      verificationTier: user.verificationTier,
      verified: user.isVerified,
      isVerified: user.isVerified,
      createdAt: user.createdAt,
    };

    logger.info('SSO: User logged in successfully:', { userId: user.id, email: user.email });

    // Do not return tokens in the response body; rely on HttpOnly cookies only
    return res.json({
      success: true,
      user: userResponse,
      message: 'Login successful',
    });
  } catch (error) {
    logger.error('SSO: Login error:', error);
    return res.status(500).json({
      success: false,
      error: {
        code: 'LOGIN_FAILED',
        message: 'Failed to login',
      },
    });
  }
});

/**
 * POST /auth/refresh
 * Refresh access token using refresh token from cookie
 */
router.post('/refresh', async (req: Request, res: Response) => {
  try {
    // Accept refresh token from cookie (preferred), Authorization header, or request body
    let refreshToken = req.cookies.refresh_token as string | undefined;
    const authHeader = req.headers.authorization as string | undefined;
    if (!refreshToken && authHeader && authHeader.startsWith('Bearer ')) {
      refreshToken = authHeader.substring(7);
    }
    if (!refreshToken && req.body && typeof req.body.refreshToken === 'string') {
      refreshToken = req.body.refreshToken;
    }

    // Record where a refresh token appears (cookie / auth header / body) for debugging purposes
    const tokenSources = {
      cookie: !!req.cookies.refresh_token,
      authHeader: !!(authHeader && authHeader.startsWith('Bearer ')),
      body: !!(req.body && typeof req.body.refreshToken === 'string')
    };

    if (!refreshToken) {
      // Don't log token source details when no token is present to reduce log noise from unauthenticated clients.
      return res.status(401).json({
        success: false,
        error: {
          code: 'NO_REFRESH_TOKEN',
          message: 'Refresh token required',
        },
      });
    }

    // Log an info-level message with limited context to aid debugging in staging.
    logger.info('SSO: Refresh token request - sources', { ip: req.ip, path: req.path, origin: req.headers.origin, tokenSources });

  // Check if refresh token exists in persistent store; if missing or expired, fall back to JWT verification
  const tokenData = await refreshTokenStore.get(refreshToken);
    let decoded: any;
    if (tokenData && new Date(tokenData.expiresAt) >= new Date()) {
      try {
        decoded = jwt.verify(refreshToken, REFRESH_SECRET) as any;
      } catch {
  // Invalid signature/expired despite store; remove and treat as invalid
  await refreshTokenStore.delete(refreshToken);
        return res.status(401).json({
          success: false,
          error: { code: 'INVALID_REFRESH_TOKEN', message: 'Invalid or expired refresh token' },
        });
      }
    } else {
      // Not in memory (e.g., another instance or restart). Verify JWT directly.
      try {
        decoded = jwt.verify(refreshToken, REFRESH_SECRET) as any;
        // Optionally re-add to the persistent store with remaining lifetime (best-effort)
        const remaining = 7 * 24 * 60 * 60; // seconds
        await refreshTokenStore.set(refreshToken, decoded.id || decoded.userId, remaining);
      } catch {
        return res.status(401).json({
          success: false,
          error: { code: 'INVALID_REFRESH_TOKEN', message: 'Invalid or expired refresh token' },
        });
      }
    }

    // Get user
    const user = await prisma.user.findUnique({
      where: { id: decoded.id },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        businessName: true,
        userType: true,
        verificationTier: true,
        isVerified: true,
        createdAt: true,
      },
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        error: {
          code: 'USER_NOT_FOUND',
          message: 'User not found',
        },
      });
    }

    // Generate new access token
    const newAccessToken = generateAccessToken(user);

  // Set new access token cookie
    // Set both legacy and new cookie names for compatibility across apps
    res.cookie('vikareta_access_token', newAccessToken, {
      ...COOKIE_CONFIG,
      maxAge: 60 * 60 * 1000 // 1 hour (matches ACCESS_TOKEN_EXPIRY)
    });

    res.cookie('access_token', newAccessToken, {
      ...COOKIE_CONFIG,
      maxAge: 60 * 60 * 1000 // 1 hour (matches ACCESS_TOKEN_EXPIRY)
    });

  // Create user response
    const userResponse = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      name: `${user.firstName} ${user.lastName}`,
      businessName: user.businessName,
      role: user.userType,
      userType: user.userType,
      verificationTier: user.verificationTier,
      verified: user.isVerified,
      isVerified: user.isVerified,
      createdAt: user.createdAt,
    };

    logger.info('SSO: Token refreshed successfully:', { userId: user.id });

    return res.json({ success: true, user: userResponse });
  } catch (error) {
    logger.error('SSO: Token refresh error:', error);
    return res.status(401).json({
      success: false,
      error: {
        code: 'INVALID_REFRESH_TOKEN',
        message: 'Invalid refresh token',
      },
    });
  }
});

/**
 * POST /auth/sso-token
 * Issue a short-lived signed token (JWT) that target subdomains can validate
 * and use to set their own HttpOnly cookie for SSO. This endpoint requires an
 * authenticated user (access token) to be present.
 *
 * Body: { target: string }
 */
router.post('/sso-token', async (req: Request, res: Response) => {
  try {
    // Require authenticated access via cookie or Authorization header
  const accessToken = req.headers.authorization?.startsWith('Bearer ')
      ? req.headers.authorization!.substring(7)
      : (req.cookies.vikareta_access_token || req.cookies.access_token);
    if (!accessToken) {
      return res.status(401).json({ success: false, error: { code: 'NO_TOKEN', message: 'Access token required' } });
    }

    let decoded: any;
    try {
      decoded = jwt.verify(accessToken, JWT_SECRET) as any;
    } catch {
      return res.status(401).json({ success: false, error: { code: 'INVALID_TOKEN', message: 'Invalid access token' } });
    }

    const target = req.body?.target;
    if (!target) {
      return res.status(400).json({ success: false, error: { code: 'MISSING_TARGET', message: 'Target host required' } });
    }

    // Ensure the requesting user has permission to request an SSO token for the target
    const requestingUser = await prisma.user.findUnique({ where: { id: decoded.id }, select: { id: true, userType: true } });
    if (!requestingUser) {
      return res.status(404).json({ success: false, error: { code: 'USER_NOT_FOUND', message: 'User not found' } });
    }

    const targetStr = String(target).toLowerCase();
    const isDashboardTarget = targetStr.includes('dashboard');
    const isAdminTarget = targetStr.includes('admin');

    // Dashboard SSO should only be issued to sellers or users marked as both
    if (isDashboardTarget && !['seller', 'both'].includes(requestingUser.userType)) {
      return res.status(403).json({ success: false, error: { code: 'FORBIDDEN', message: 'Insufficient role to request SSO for dashboard' } });
    } 

    // Admin SSO should only be issued to admin users
    if (isAdminTarget && requestingUser.userType !== 'admin') {
      return res.status(403).json({ success: false, error: { code: 'FORBIDDEN', message: 'Insufficient role to request SSO for admin' } });
    }

    // Create a very short lived SSO token
    const SSO_SECRET = process.env.SSO_SECRET || process.env.JWT_SECRET || 'sso-secret';
    const ssoToken = jwt.sign({ sub: decoded.id, email: decoded.email, aud: target }, SSO_SECRET, { expiresIn: '60s' });

    return res.json({ success: true, token: ssoToken });
  } catch (error) {
    logger.error('SSO token issuance failed:', error);
    return res.status(500).json({ success: false, error: { code: 'SSO_ISSUE_FAILED', message: 'Failed to issue SSO token' } });
  }
});

/**
 * POST /auth/validate-sso
 * Validate an incoming SSO token (short-lived) and ensure the referenced user exists.
 * Body: { token: string }
 * Returns: { success: true, user: { id, email } } on valid token
 */
router.post('/validate-sso', async (req: Request, res: Response) => {
  try {
    const token = req.body?.token;
    if (!token) return res.status(400).json({ success: false, error: { code: 'MISSING_TOKEN', message: 'Token required' } });

    const SSO_SECRET = process.env.SSO_SECRET || process.env.JWT_SECRET || 'sso-secret';
    let payload: any;
    try {
      payload = jwt.verify(token, SSO_SECRET) as any;
    } catch {
      return res.status(401).json({ success: false, error: { code: 'INVALID_SSO', message: 'Invalid or expired SSO token' } });
    }

    // Verify user existence and active status
    const user = await prisma.user.findUnique({ where: { id: payload.sub } });
    if (!user) return res.status(404).json({ success: false, error: { code: 'USER_NOT_FOUND', message: 'User not found' } });

    // Enforce audience-based role constraints: dashboard -> sellers/both, admin -> admin
    const aud = payload.aud && typeof payload.aud === 'string' ? payload.aud.toLowerCase() : '';
    const audIsDashboard = aud.includes('dashboard');
    const audIsAdmin = aud.includes('admin');
    if (audIsDashboard && !['seller', 'both'].includes(user.userType)) {
      return res.status(403).json({ success: false, error: { code: 'FORBIDDEN', message: 'User not authorized for dashboard SSO' } });
    }
    if (audIsAdmin && user.userType !== 'admin') {
      return res.status(403).json({ success: false, error: { code: 'FORBIDDEN', message: 'User not authorized for admin SSO' } });
    }

    // Optionally verify audience claim matches expected host pattern
    if (payload.aud && typeof payload.aud === 'string') {
      // allow if aud equals host or contains it
      // Additional checks can be added here
    }

  // Issue fresh cookies for the subdomain to use via setAuthCookies
  await setAuthCookies(res, user);
  return res.json({ success: true, user: { id: user.id, email: user.email } });
  } catch (error) {
    logger.error('SSO validation failed:', error);
    return res.status(500).json({ success: false, error: { code: 'SSO_VALIDATION_FAILED', message: 'Failed to validate SSO token' } });
  }
});

/**
 * POST /auth/exchange-sso
 * Validate SSO token and set HttpOnly cookies in the response so the calling
 * subdomain can complete SSO without managing tokens in JS.
 * Body: { token: string }
 */
router.post('/exchange-sso', async (req: Request, res: Response) => {
  try {
    const token = req.body?.token as string | undefined;
    if (!token) return res.status(400).json({ success: false, error: { code: 'MISSING_TOKEN', message: 'Token required' } });

    const SSO_SECRET = process.env.SSO_SECRET || process.env.JWT_SECRET || 'sso-secret';
    let payload: any;
    try {
      payload = jwt.verify(token, SSO_SECRET) as any;
    } catch {
      return res.status(401).json({ success: false, error: { code: 'INVALID_SSO', message: 'Invalid or expired SSO token' } });
    }

    const user = await prisma.user.findUnique({ where: { id: payload.sub } });
    if (!user) return res.status(404).json({ success: false, error: { code: 'USER_NOT_FOUND', message: 'User not found' } });

    // Enforce audience-based role constraints
    const aud = payload.aud && typeof payload.aud === 'string' ? payload.aud.toLowerCase() : '';
    if (aud.includes('dashboard') && !['seller', 'both'].includes(user.userType)) {
      return res.status(403).json({ success: false, error: { code: 'FORBIDDEN', message: 'User not authorized for dashboard SSO' } });
    }
    if (aud.includes('admin') && user.userType !== 'admin') {
      return res.status(403).json({ success: false, error: { code: 'FORBIDDEN', message: 'User not authorized for admin SSO' } });
    }

  // Set cookies directly to mirror standard login
  await setAuthCookies(res, user);

    return res.json({ success: true });
  } catch (error) {
    logger.error('SSO exchange failed:', error);
    return res.status(500).json({ success: false, error: { code: 'SSO_EXCHANGE_FAILED', message: 'Failed to exchange SSO token' } });
  }
});

/**
 * GET /auth/me
 * Get current user profile using access token from cookie
 */
router.get('/me', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.authUser!.id },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        businessName: true,
        userType: true,
        verificationTier: true,
        isVerified: true,
        phone: true,
        gstin: true,
        createdAt: true,
      },
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        error: {
          code: 'USER_NOT_FOUND',
          message: 'User not found',
        },
      });
    }

    // Create user response with name field
    const userResponse = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      name: `${user.firstName} ${user.lastName}`,
      businessName: user.businessName,
      role: user.userType,
      userType: user.userType,
      verificationTier: user.verificationTier,
      verified: user.isVerified,
      isVerified: user.isVerified,
      phone: user.phone,
      gstin: user.gstin,
      createdAt: user.createdAt,
    };

      // Do not return tokens in response body; rely on HttpOnly cookies only
      return res.json({
        success: true,
        user: userResponse,
      });
  } catch (error) {
    logger.error('SSO: Get user error:', error);
    return res.status(500).json({
      success: false,
      error: {
        code: 'GET_USER_FAILED',
        message: 'Failed to get user information',
      },
    });
  }
});

/**
 * POST /auth/logout
 * Logout and clear all cookies across subdomains
 */
router.post('/logout', async (req: Request, res: Response) => {
  try {
    const refreshToken = req.cookies.refresh_token;

    // Remove refresh token from storage
    if (refreshToken) {
      await refreshTokenStore.delete(refreshToken);
    }

    // Clear all authentication cookies
    clearAuthCookies(res);

    logger.info('SSO: User logged out successfully');

    return res.json({
      success: true,
      message: 'Logged out successfully',
    });
  } catch (error) {
    logger.error('SSO: Logout error:', error);
    return res.status(500).json({
      success: false,
      error: {
        code: 'LOGOUT_ERROR',
        message: 'Logout failed',
      },
    });
  }
});

/**
 * GET /auth/debug-oauth
 * Return non-sensitive OAuth runtime config to verify deployment correctness.
 * Temporarily made public for debugging - REMOVE IN PRODUCTION.
 */
router.get('/debug-oauth', (req: Request, res: Response) => {
  // Only allow in development or with debug key
  const key = String(req.query.key || '');
  if (process.env.NODE_ENV === 'production' && !key) {
    return res.status(403).json({ success: false, message: 'Debug key required in production' });
  }
  
  return res.json({
    success: true,
    google: {
      hasClientId: !!process.env.GOOGLE_CLIENT_ID,
      clientIdSuffix: (process.env.GOOGLE_CLIENT_ID || '').slice(-12),
      hasClientSecret: !!process.env.GOOGLE_CLIENT_SECRET,
      secretLength: process.env.GOOGLE_CLIENT_SECRET ? process.env.GOOGLE_CLIENT_SECRET.length : 0,
      callbackURL: process.env.GOOGLE_CALLBACK_URL || 'NOT_SET',
    },
    frontendUrl: process.env.FRONTEND_URL || 'NOT_SET',
    oauthDebug: process.env.OAUTH_DEBUG === 'true',
    nodeEnv: process.env.NODE_ENV,
    ts: new Date().toISOString(),
  });
});/**
 * PUT /auth/profile
 * Update user profile
 */
router.put('/profile', verifyAccessToken, [
  body('firstName').optional().trim().isLength({ min: 1 }).withMessage('First name cannot be empty'),
  body('lastName').optional().trim().isLength({ min: 1 }).withMessage('Last name cannot be empty'),
  body('businessName').optional().trim(),
  body('phone').optional().isMobilePhone('any').withMessage('Invalid phone number'),
  body('gstin').optional().isLength({ min: 15, max: 15 }).withMessage('GSTIN must be 15 characters'),
  handleValidationErrors,
], async (req: Request, res: Response) => {
  try {
    const { firstName, lastName, businessName, phone, gstin } = req.body;

    const user = await prisma.user.update({
      where: { id: req.authUser!.id },
      data: {
        firstName,
        lastName,
        businessName,
        phone,
        gstin,
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        businessName: true,
        userType: true,
        verificationTier: true,
        isVerified: true,
        phone: true,
        gstin: true,
        createdAt: true,
      },
    });

    // Create user response with name field
    const userResponse = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      name: `${user.firstName} ${user.lastName}`,
      businessName: user.businessName,
      role: user.userType,
      userType: user.userType,
      verificationTier: user.verificationTier,
      verified: user.isVerified,
      isVerified: user.isVerified,
      phone: user.phone,
      gstin: user.gstin,
      createdAt: user.createdAt,
    };

    logger.info('SSO: Profile updated successfully:', { userId: user.id });

    return res.json({
      success: true,
      user: userResponse,
      message: 'Profile updated successfully',
    });
  } catch (error) {
    logger.error('SSO: Profile update error:', error);
    return res.status(500).json({
      success: false,
      error: {
        code: 'PROFILE_UPDATE_FAILED',
        message: 'Failed to update profile',
      },
    });
  }
});

// POST /auth/send-otp
router.post('/send-otp', [
  body('identifier').isString().notEmpty(),
  body('type').isIn(['email', 'phone']),
  handleValidationErrors
], async (req: Request, res: Response) => {
  try {
    const { identifier, type } = req.body;

    // Generate and store OTP
    const otp = await OtpService.generateOtp(identifier, type);

    // Try to send via configured notification channel (best-effort)
    (async () => {
      try {
        const channel = type === 'email' ? 'email' : 'sms';
        await notificationService.sendNotification({
          userId: 'system',
          templateName: 'verification_otp',
          channel: channel as any,
          recipient: identifier,
          variables: { otp, identifier, expiryMinutes: process.env.OTP_EXPIRY_MINUTES || '10', appName: 'Vikareta', supportEmail: process.env.SUPPORT_EMAIL || 'support@vikareta.com', userName: 'there', year: new Date().getFullYear().toString() }
        });
        logger.info('Sent OTP notification (best-effort) to', { identifier, type });
      } catch (sendErr) {
        logger.warn('Failed to send OTP notification (best-effort):', { error: sendErr && (sendErr as any).message ? (sendErr as any).message : String(sendErr) });
      }
    })();

    // In development return the OTP for convenience
    const responsePayload: any = { success: true, message: 'OTP generated' };
    if (process.env.NODE_ENV === 'development') responsePayload.otp = otp;

    return res.json(responsePayload);
  } catch (error) {
    logger.error('Send OTP failed:', error);
    return res.status(500).json({ success: false, error: { code: 'OTP_GENERATION_FAILED', message: 'Failed to generate OTP' } });
  }
});

// POST /auth/verify-otp
router.post('/verify-otp', [
  body('identifier').isString().notEmpty(),
  body('type').isIn(['email', 'phone']),
  body('otp').isString().isLength({ min: 4, max: 8 }),
  handleValidationErrors
], async (req: Request, res: Response) => {
  try {
    const { identifier, type, otp } = req.body;

    const ok = await OtpService.verifyOtp(identifier, type, otp);
    if (!ok) {
      return res.status(400).json({ success: false, error: { code: 'INVALID_OTP', message: 'Invalid or expired OTP' } });
    }

    // Mark user as verified when identifier maps to a user
    try {
      const user = type === 'email'
        ? await prisma.user.findUnique({ where: { email: identifier } })
        : await prisma.user.findFirst({ where: { phone: identifier } });

      if (user) {
        await prisma.user.update({ where: { id: user.id }, data: { isVerified: true } });
        logger.info('User marked verified via OTP', { userId: user.id, identifier });
      }
    } catch (uErr) {
      logger.warn('Failed to mark user verified after OTP (non-fatal):', uErr);
    }

    return res.json({ success: true, message: 'OTP verified' });
  } catch (error) {
    logger.error('Verify OTP failed:', error);
    return res.status(500).json({ success: false, error: { code: 'OTP_VERIFY_FAILED', message: 'Failed to verify OTP' } });
  }
});

// --- OAuth Routes ---

// Initiate Google OAuth
router.get('/google', (req: Request, res: Response, next: any) => {
  // Always log Google OAuth initiation for debugging
  logger.info('OAuth(Google): Initiating', {
    origin: req.headers.origin,
    state: typeof req.query.state === 'string' ? req.query.state : '',
    host: req.headers.host,
    userAgent: req.headers['user-agent'],
    callbackURL: process.env.GOOGLE_CALLBACK_URL || null,
    timestamp: new Date().toISOString(),
  });
  return passport.authenticate('google', { scope: ['profile', 'email'], session: false })(req, res, next);
});

// Google callback
router.get('/google/callback', (req: Request, res: Response, next: any) => {
  try {
    // Always log callback details for debugging
    try {
    const c = typeof req.query.code === 'string' ? req.query.code : '';
    const s = typeof req.query.state === 'string' ? req.query.state : '';
    const details: any = { 
      hasCode: !!c, 
      codeLen: c ? c.length : 0, 
      state: s,
      host: req.headers.host,
      xForwardedHost: req.headers['x-forwarded-host'],
      xForwardedProto: req.headers['x-forwarded-proto'],
      xForwardedFor: req.headers['x-forwarded-for'],
      userAgent: req.headers['user-agent'],
      timestamp: new Date().toISOString(),
    };
    logger.info('OAuth(Google): Callback received', details);
  } catch (e) {
    logger.warn('Failed to log Google callback query', { error: (e as any)?.message || String(e) });
  }
  // If Google sent an error (e.g., access_denied), short-circuit to relay with details
  if (typeof req.query.error === 'string') {
    logger.error('OAuth(Google): Google sent error in callback', {
      error: req.query.error,
      error_description: req.query.error_description,
      state: req.query.state,
      timestamp: new Date().toISOString(),
    });
    const state = typeof req.query.state === 'string' ? req.query.state : '';
    const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
    const err = encodeURIComponent(req.query.error);
    const errDesc = encodeURIComponent(String(req.query.error_description || ''));
    const relay = `${frontendBase}/sso-relay.html?error=${err}${errDesc ? '&error_description=' + errDesc : ''}${state ? '&state=' + encodeURIComponent(state) : ''}`;
    return res.redirect(relay);
  }

  // Log the exact code we're about to send to Google for token exchange
  const authCode = typeof req.query.code === 'string' ? req.query.code : '';
  logger.info('OAuth(Google): About to authenticate with code', {
    hasCode: !!authCode,
    codeLength: authCode.length,
    codePrefix: authCode.substring(0, 10),
    codeSuffix: authCode.substring(authCode.length - 10),
    fullCode: authCode, // Temporarily log full code for debugging
    allQueryParams: JSON.stringify(req.query),
    timestamp: new Date().toISOString(),
  });

  logger.info('OAuth(Google): Starting passport authentication', {
    timestamp: new Date().toISOString(),
  });

  passport.authenticate('google', { session: false }, async (err: any, result: any) => {
    logger.info('OAuth(Google): Passport authenticate callback invoked', {
      hasError: !!err,
      hasResult: !!result,
      errorType: err ? err.constructor.name : null,
      resultType: result ? typeof result : null,
      timestamp: new Date().toISOString(),
    });

    if (err || !result) {
      // Always log errors for debugging with maximum detail
      logger.error('OAuth(Google): Callback error - detailed', {
        message: err && err.message,
        name: err && err.name,
        status: err && (err.status || err.statusCode),
        statusCode: err && err.statusCode,
        code: err && err.code,
        oauthError: err && err.oauthError,
        oauthResponse: err && err.oauthResponse,
        data: err && err.data,
        stack: err && err.stack ? err.stack.substring(0, 1000) : undefined,
        hasCode: typeof req.query.code === 'string',
        codeLength: typeof req.query.code === 'string' ? req.query.code.length : 0,
        hasResult: !!result,
        errorType: err && err.constructor ? err.constructor.name : typeof err,
        timestamp: new Date().toISOString(),
        // Google specific error fields
        error_description: err && err.error_description,
        error_uri: err && err.error_uri,
        // Raw error for inspection
        rawError: err ? JSON.stringify(err, null, 2).substring(0, 2000) : undefined,
      });
      
      const state = typeof req.query.state === 'string' ? req.query.state : '';
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      const errMsg = err && err.message ? encodeURIComponent(err.message) : '1';
      const relay = `${frontendBase}/sso-relay.html?error=${errMsg}${state ? '&state=' + encodeURIComponent(state) : ''}`;
      return res.redirect(relay);
    }

    try {
      // Set cookies and redirect to frontend relay page for popup flows
  await setAuthCookies(res, result.user);

      logger.info('OAuth(Google): Success - cookies set', {
        userId: result.user?.id,
        email: result.user?.email,
        timestamp: new Date().toISOString(),
      });

      const state = typeof req.query.state === 'string' ? req.query.state : '';
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      const relay = `${frontendBase}/sso-relay.html${state ? '?state=' + encodeURIComponent(state) : ''}`;
      return res.redirect(relay);
    } catch (e) {
      logger.error('OAuth(Google): Post-processing failed', {
        error: (e as any)?.message || String(e),
        timestamp: new Date().toISOString(),
      });
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      return res.redirect(`${frontendBase}/sso-relay.html?error=1`);
    }
  })(req, res, next);
  } catch (globalError) {
    logger.error('OAuth(Google): Global callback error', {
      error: (globalError as any)?.message || String(globalError),
      stack: (globalError as any)?.stack?.substring(0, 1000),
      timestamp: new Date().toISOString(),
    });
    const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
    return res.redirect(`${frontendBase}/sso-relay.html?error=global`);
  }
});

// Initiate LinkedIn OAuth
router.get('/linkedin', passport.authenticate('linkedin', { scope: ['r_emailaddress', 'r_liteprofile'], session: false }));

// LinkedIn callback
router.get('/linkedin/callback', (req: Request, res: Response, next: any) => {
  passport.authenticate('linkedin', { session: false }, async (err: any, result: any) => {
    if (err || !result) {
  logger.error('LinkedIn OAuth callback error', err);
  const state = typeof req.query.state === 'string' ? req.query.state : '';
  const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
  const relay = `${frontendBase}/sso-relay.html?error=1${state ? '&state=' + encodeURIComponent(state) : ''}`;
  return res.redirect(relay);
    }

    try {
  await setAuthCookies(res, result.user);
      const state = typeof req.query.state === 'string' ? req.query.state : '';
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      const relay = `${frontendBase}/sso-relay.html${state ? '?state=' + encodeURIComponent(state) : ''}`;
      return res.redirect(relay);
    } catch (e) {
      logger.error('LinkedIn OAuth post-processing failed', e);
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      return res.redirect(`${frontendBase}/sso-relay.html?error=1`);
    }
  })(req, res, next);
});

// Initiate DigiLocker OAuth (redirect to provider)
router.get('/digilocker', (req: Request, res: Response) => {
  const state = typeof req.query.state === 'string' ? req.query.state : undefined;
  const url = DigiLockerService.getAuthorizationUrl(state);
  return res.redirect(url);
});

// --- OAuth2 Authorization Code Flow (simple implementation) ---

/**
 * GET /auth/oauth/authorize
 * Query: client_id, redirect_uri, state, code_challenge (optional), code_challenge_method
 * Requires authenticated user via cookie or Authorization header. Issues a short-lived code and redirects to redirect_uri.
 */
router.get('/oauth/authorize', async (req: Request, res: Response) => {
  try {
    const accessToken = req.headers.authorization?.startsWith('Bearer ')
      ? req.headers.authorization!.substring(7)
      : (req.cookies.vikareta_access_token || req.cookies.access_token);

    if (!accessToken) {
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      const returnTo = encodeURIComponent(req.originalUrl || '/');
      return res.redirect(`${frontendBase}/login?return_to=${returnTo}`);
    }

    let decoded: any;
    try { decoded = jwt.verify(accessToken, JWT_SECRET) as any; } catch { 
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      const returnTo = encodeURIComponent(req.originalUrl || '/');
      return res.redirect(`${frontendBase}/login?return_to=${returnTo}`);
    }

    const clientId = typeof req.query.client_id === 'string' ? req.query.client_id : undefined;
    const redirectUri = typeof req.query.redirect_uri === 'string' ? req.query.redirect_uri : undefined;
    const state = typeof req.query.state === 'string' ? req.query.state : undefined;
    const codeChallenge = typeof req.query.code_challenge === 'string' ? req.query.code_challenge : undefined;

    if (!clientId || !redirectUri) {
      return res.status(400).json({ success: false, error: { code: 'INVALID_REQUEST', message: 'Missing client_id or redirect_uri' } });
    }

    const code = crypto.randomBytes(24).toString('hex');
    const entry = {
      sub: decoded.id,
      clientId,
      redirectUri,
      codeChallenge: codeChallenge || null,
      createdAt: new Date().toISOString()
    };

  const setOk = await cacheService.set('authCode', code, entry, 120);
  logger.info('cacheService.set for authCode', { codePrefix: code.substring(0, 8), codeLen: code.length, ok: setOk });

    const separator = redirectUri.includes('?') ? '&' : '?';
    const forwarded = `${redirectUri}${separator}code=${encodeURIComponent(code)}${state ? `&state=${encodeURIComponent(state)}` : ''}`;
    return res.redirect(forwarded);
  } catch (err) {
    logger.error('OAuth authorize error', err);
    return res.status(500).json({ success: false, error: { code: 'OAUTH_AUTHORIZE_FAILED', message: 'Failed to authorize' } });
  }
});

/**
 * POST /auth/oauth/token
 * Body: grant_type=authorization_code, code, redirect_uri, client_id, code_verifier (if PKCE)
 */
router.post('/oauth/token', async (req: Request, res: Response) => {
  try {
    const grantType = req.body?.grant_type;
    if (grantType !== 'authorization_code') {
      return res.status(400).json({ success: false, error: { code: 'UNSUPPORTED_GRANT', message: 'Only authorization_code grant supported' } });
    }

    const code = typeof req.body.code === 'string' ? req.body.code : undefined;
    const redirectUri = typeof req.body.redirect_uri === 'string' ? req.body.redirect_uri : undefined;
    const clientId = typeof req.body.client_id === 'string' ? req.body.client_id : undefined;
    const codeVerifier = typeof req.body.code_verifier === 'string' ? req.body.code_verifier : undefined;

    if (!code || !redirectUri || !clientId) {
      return res.status(400).json({ success: false, error: { code: 'INVALID_REQUEST', message: 'Missing parameters' } });
    }

    const entry: any = await cacheService.get('authCode', code) as any;
    logger.info('cacheService.get for authCode', { codePrefix: code ? code.substring(0, 8) : null, found: !!entry });
    if (!entry) {
      // Log cache stats to assist debugging
      try {
        const stats = cacheService.getStats();
        logger.warn('OAuth token exchange failed - authCode missing', { codePrefix: code ? code.substring(0, 8) : null, cacheStats: stats });
      } catch (e) {
        logger.warn('Failed to get cache stats while handling missing authCode', { error: (e as any)?.message || String(e) });
      }
      return res.status(400).json({ success: false, error: { code: 'INVALID_CODE', message: 'Invalid or expired code' } });
    }

    if (entry.clientId !== clientId || entry.redirectUri !== redirectUri) {
      return res.status(400).json({ success: false, error: { code: 'INVALID_REQUEST', message: 'Redirect URI or client mismatch' } });
    }

    if (entry.codeChallenge) {
      if (!codeVerifier) return res.status(400).json({ success: false, error: { code: 'INVALID_REQUEST', message: 'code_verifier required' } });
      const hashed = crypto.createHash('sha256').update(codeVerifier).digest();
      const base64 = hashed.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
      if (base64 !== entry.codeChallenge) {
        return res.status(400).json({ success: false, error: { code: 'INVALID_GRANT', message: 'PKCE verification failed' } });
      }
    }

    const user = await prisma.user.findUnique({ where: { id: entry.sub } });
    if (!user) return res.status(404).json({ success: false, error: { code: 'USER_NOT_FOUND', message: 'User not found' } });

    // Set cookies for the caller (useful for subdomain token exchange)
    await setAuthCookies(res, user);

  const delOk = await cacheService.delete('authCode', code);
  logger.info('cacheService.delete for authCode', { codePrefix: code.substring(0, 8), deleted: delOk });

    return res.json({ success: true, user: { id: user.id, email: user.email } });
  } catch (err) {
    logger.error('OAuth token exchange error', err);
    return res.status(500).json({ success: false, error: { code: 'OAUTH_TOKEN_FAILED', message: 'Token exchange failed' } });
  }
});

// DigiLocker callback
router.get('/digilocker/callback', async (req: Request, res: Response) => {
  const code = typeof req.query.code === 'string' ? req.query.code : undefined;
  if (!code) {
    return res.redirect(`${process.env.FRONTEND_URL || '/'}?auth=failed`);
  }

    try {
      const result = await DigiLockerService.handleDigiLockerAuth(code);
  await setAuthCookies(res, result.user);
      const state = typeof req.query.state === 'string' ? req.query.state : '';
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      const relay = `${frontendBase}/sso-relay.html${state ? '?state=' + encodeURIComponent(state) : ''}`;
      return res.redirect(relay);
    } catch (e) {
      logger.error('DigiLocker callback failed', e);
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      return res.redirect(`${frontendBase}/sso-relay.html?error=1`);
    }
});

export default router;

// DEBUG: Temporary cache test endpoints - remove in production
router.post('/debug/cache/authcode', async (req: Request, res: Response) => {
  try {
    const { code, sub, clientId, redirectUri } = req.body;
    if (!code || !sub || !clientId || !redirectUri) return res.status(400).json({ success: false, message: 'missing' });
    const entry = { sub, clientId, redirectUri, createdAt: new Date().toISOString() };
    const ok = await cacheService.set('authCode', code, entry, 120);
    logger.info('DEBUG set authCode', { codePrefix: code.substring(0, 8), ok });
    return res.json({ success: ok });
  } catch (e) {
    logger.error('DEBUG set authCode failed', e);
    return res.status(500).json({ success: false });
  }
});

router.get('/debug/cache/authcode/:code', async (req: Request, res: Response) => {
  try {
    const code = req.params.code;
    const entry = await cacheService.get('authCode', code);
    logger.info('DEBUG get authCode', { codePrefix: code.substring(0, 8), found: !!entry });
    return res.json({ success: true, entry: entry || null });
  } catch (e) {
    logger.error('DEBUG get authCode failed', e);
    return res.status(500).json({ success: false });
  }
});

router.delete('/debug/cache/authcode/:code', async (req: Request, res: Response) => {
  try {
    const code = req.params.code;
    const ok = await cacheService.delete('authCode', code);
    logger.info('DEBUG delete authCode', { codePrefix: code.substring(0, 8), deleted: ok });
    return res.json({ success: ok });
  } catch (e) {
    logger.error('DEBUG delete authCode failed', e);
    return res.status(500).json({ success: false });
  }
});