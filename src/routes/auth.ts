/**
 * SSO Authentication Routes
 * Secure Cross-Subdomain Single Sign-On with JWT + Refresh Tokens in HttpOnly Cookies
 */

import { Router, Request, Response } from 'express';
import { body, validationResult } from 'express-validator';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { PrismaClient } from '@prisma/client';

import { logger } from '@/utils/logger';
import passport from '@/config/passport';
import { DigiLockerService } from '@/services/digilocker.service';
import { OtpService } from '@/services/otp.service';
import { notificationService } from '@/services/notification.service';

const router = Router();
const prisma = new PrismaClient();

// JWT Configuration
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key';
const REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'your-super-secret-refresh-key';
const ACCESS_TOKEN_EXPIRY = '1h'; // Increased from 15m to 1h to reduce frequent logouts
const REFRESH_TOKEN_EXPIRY = '7d';

// Cookie Configuration
const COOKIE_CONFIG = {
  domain: process.env.NODE_ENV === 'production' ? '.vikareta.com' : undefined,
  path: '/',
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: process.env.NODE_ENV === 'production' ? 'none' as const : 'lax' as const
};

// Log auth routes initialization and key env flags (non-sensitive)
try {
  logger.info('Auth routes initialized', {
    oauthDebug: process.env.OAUTH_DEBUG === 'true',
    frontendUrl: process.env.FRONTEND_URL || null,
    googleCallbackURL: process.env.GOOGLE_CALLBACK_URL || null,
  });
} catch {
  // ignore
}

// Lightweight request logger for auth routes when debugging is enabled
router.use((req, _res, next) => {
  if (process.env.OAUTH_DEBUG === 'true') {
    logger.info('Auth route hit', {
      method: req.method,
      url: req.originalUrl,
      path: req.path,
      query: req.query,
      origin: req.headers.origin,
      host: req.headers.host,
      ua: req.headers['user-agent']
    });
  }
  next();
});



// In-memory refresh token storage (replace with Redis in production)
const refreshTokens = new Map<string, {
  userId: string;
  createdAt: Date;
  expiresAt: Date;
}>();

// Validation middleware
const handleValidationErrors = (req: Request, res: Response, next: any) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      error: {
        code: 'VALIDATION_ERROR',
        message: 'Invalid input data',
        details: errors.array(),
      },
    });
  }
  return next();
};

/**
 * Generate JWT Access Token
 */
function generateAccessToken(user: any) {
  return jwt.sign(
    {
      id: user.id,
      email: user.email,
      role: user.userType,
      userType: user.userType
    },
    JWT_SECRET,
    { expiresIn: ACCESS_TOKEN_EXPIRY }
  );
}

/**
 * Generate Refresh Token
 */
function generateRefreshToken(user: any) {
  const refreshToken = jwt.sign(
    { id: user.id, email: user.email },
    REFRESH_SECRET,
    { expiresIn: REFRESH_TOKEN_EXPIRY }
  );

  // Store refresh token
  refreshTokens.set(refreshToken, {
    userId: user.id,
    createdAt: new Date(),
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
  });

  return refreshToken;
}

// CSRF token generation moved to security middleware

/**
 * Set Authentication Cookies
 */
function setAuthCookies(res: Response, user: any) {
  const accessToken = generateAccessToken(user);
  const refreshToken = generateRefreshToken(user);
  // CSRF token will be generated by the /csrf-token endpoint when needed

  // Set HttpOnly cookies for tokens
  res.cookie('access_token', accessToken, {
    ...COOKIE_CONFIG,
    maxAge: 60 * 60 * 1000 // 1 hour (matches ACCESS_TOKEN_EXPIRY)
  });

  res.cookie('refresh_token', refreshToken, {
    ...COOKIE_CONFIG,
    maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
  });

  // CSRF token is set separately via /csrf-token endpoint
}

/**
 * Clear Authentication Cookies
 */
function clearAuthCookies(res: Response) {
  const expiredConfig = {
    ...COOKIE_CONFIG,
    expires: new Date(0)
  };

  res.cookie('access_token', '', expiredConfig);
  res.cookie('refresh_token', '', expiredConfig);
  res.cookie('XSRF-TOKEN', '', { ...expiredConfig, httpOnly: false });
}

/**
 * Middleware: Verify Access Token from Cookie or Authorization Header
 */
function verifyAccessToken(req: Request, res: Response, next: any) {
  // Try to get token from Authorization header first (Bearer token)
  let accessToken = null;
  const authHeader = req.headers.authorization;
  
  if (authHeader && authHeader.startsWith('Bearer ')) {
    accessToken = authHeader.substring(7); // Remove 'Bearer ' prefix
  } else {
    // Fallback to cookie-based token
    accessToken = req.cookies.access_token;
  }

  if (!accessToken) {
    return res.status(401).json({
      success: false,
      error: { code: 'NO_TOKEN', message: 'Access token required' }
    });
  }

  try {
    const decoded = jwt.verify(accessToken, JWT_SECRET) as any;
    req.authUser = decoded;
    next();
  } catch (error: any) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        success: false,
        error: { code: 'TOKEN_EXPIRED', message: 'Access token expired' }
      });
    }

    return res.status(401).json({
      success: false,
      error: { code: 'INVALID_TOKEN', message: 'Invalid access token' }
    });
  }
}

// CSRF verification is now handled by global middleware - no duplicate needed

/**
 * POST /auth/register
 * Register new user with SSO cookies
 */
router.post('/register', [
  body('email').isEmail().withMessage('Valid email is required'),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters'),
  body('firstName').trim().isLength({ min: 1 }).withMessage('First name is required'),
  body('lastName').trim().isLength({ min: 1 }).withMessage('Last name is required'),
  body('userType').isIn(['buyer', 'seller', 'both']).withMessage('Invalid user type'),
  handleValidationErrors,
], async (req: Request, res: Response) => {
  try {
    const { email, password, firstName, lastName, userType, businessName, phone, location } = req.body;

    // Check if user already exists
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [
          { email },
          { phone: phone || undefined },
        ],
      },
    });

    if (existingUser) {
      return res.status(409).json({
        success: false,
        error: {
          code: 'USER_EXISTS',
          message: 'User with this email or phone already exists',
        },
      });
    }

    // Hash password
    const passwordHash = await bcrypt.hash(password, 12);

    // Create user
    const user = await prisma.user.create({
      data: {
        email,
        passwordHash,
        firstName,
        lastName,
        businessName,
        phone,
        location,
        userType,
        verificationTier: 'basic',
        isVerified: false,
        isActive: true,
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        businessName: true,
        userType: true,
        verificationTier: true,
        isVerified: true,
        createdAt: true,
      },
    });

    // Set authentication cookies
    setAuthCookies(res, user);

    // Create user response with name field
    const userResponse = {
      ...user,
      name: `${user.firstName} ${user.lastName}`,
      role: user.userType,
      verified: user.isVerified
    };

    logger.info('SSO: User registered successfully:', { userId: user.id, email: user.email });

    return res.status(201).json({
      success: true,
      user: userResponse,
      message: 'User registered successfully',
    });
  } catch (error) {
    logger.error('SSO: Registration error:', error);
    return res.status(500).json({
      success: false,
      error: {
        code: 'REGISTRATION_FAILED',
        message: 'Failed to register user',
      },
    });
  }
});

/**
 * POST /auth/login
 * Login with username/password and set SSO cookies
 */
router.post('/login', [
  body('email').isEmail().withMessage('Valid email is required'),
  body('password').notEmpty().withMessage('Password is required'),
  handleValidationErrors,
], async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;

    // Find user
    const user = await prisma.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        passwordHash: true,
        firstName: true,
        lastName: true,
        businessName: true,
        userType: true,
        verificationTier: true,
        isVerified: true,
        createdAt: true,
      },
    });

    if (!user || !user.passwordHash) {
      return res.status(401).json({
        success: false,
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password',
        },
      });
    }

    // Verify password
    const isValidPassword = await bcrypt.compare(password, user.passwordHash);
    if (!isValidPassword) {
      return res.status(401).json({
        success: false,
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password',
        },
      });
    }

    // Set authentication cookies
    setAuthCookies(res, user);

    // Create user response with name field
    const userResponse = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      name: `${user.firstName} ${user.lastName}`,
      businessName: user.businessName,
      role: user.userType,
      userType: user.userType,
      verificationTier: user.verificationTier,
      verified: user.isVerified,
      isVerified: user.isVerified,
      createdAt: user.createdAt,
    };

    logger.info('SSO: User logged in successfully:', { userId: user.id, email: user.email });

    // Generate tokens for localStorage storage
    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);

    // Return tokens in response body for localStorage storage
    return res.json({
      success: true,
      user: userResponse,
      accessToken: accessToken,
      refreshToken: refreshToken,
      message: 'Login successful',
    });
  } catch (error) {
    logger.error('SSO: Login error:', error);
    return res.status(500).json({
      success: false,
      error: {
        code: 'LOGIN_FAILED',
        message: 'Failed to login',
      },
    });
  }
});

/**
 * POST /auth/refresh
 * Refresh access token using refresh token from cookie
 */
router.post('/refresh', async (req: Request, res: Response) => {
  try {
    // Accept refresh token from cookie (preferred), Authorization header, or request body
    let refreshToken = req.cookies.refresh_token as string | undefined;
    const authHeader = req.headers.authorization as string | undefined;
    if (!refreshToken && authHeader && authHeader.startsWith('Bearer ')) {
      refreshToken = authHeader.substring(7);
    }
    if (!refreshToken && req.body && typeof req.body.refreshToken === 'string') {
      refreshToken = req.body.refreshToken;
    }

    // Record where a refresh token appears (cookie / auth header / body) for debugging purposes
    const tokenSources = {
      cookie: !!req.cookies.refresh_token,
      authHeader: !!(authHeader && authHeader.startsWith('Bearer ')),
      body: !!(req.body && typeof req.body.refreshToken === 'string')
    };

    if (!refreshToken) {
      // Don't log token source details when no token is present to reduce log noise from unauthenticated clients.
      return res.status(401).json({
        success: false,
        error: {
          code: 'NO_REFRESH_TOKEN',
          message: 'Refresh token required',
        },
      });
    }

    // Log an info-level message with limited context to aid debugging in staging.
    logger.info('SSO: Refresh token request - sources', { ip: req.ip, path: req.path, origin: req.headers.origin, tokenSources });

    // Check if refresh token exists in memory; if missing or expired, fall back to JWT verification
    const tokenData = refreshTokens.get(refreshToken);
    let decoded: any;
    if (tokenData && tokenData.expiresAt >= new Date()) {
      try {
        decoded = jwt.verify(refreshToken, REFRESH_SECRET) as any;
      } catch {
        // Invalid signature/expired despite map; treat as invalid
        refreshTokens.delete(refreshToken);
        return res.status(401).json({
          success: false,
          error: { code: 'INVALID_REFRESH_TOKEN', message: 'Invalid or expired refresh token' },
        });
      }
    } else {
      // Not in memory (e.g., another instance or restart). Verify JWT directly.
      try {
        decoded = jwt.verify(refreshToken, REFRESH_SECRET) as any;
        // Optionally re-add to in-memory store with remaining lifetime (best-effort)
        refreshTokens.set(refreshToken, {
          userId: decoded.id || decoded.userId,
          createdAt: new Date(),
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        });
      } catch {
        return res.status(401).json({
          success: false,
          error: { code: 'INVALID_REFRESH_TOKEN', message: 'Invalid or expired refresh token' },
        });
      }
    }

    // Get user
    const user = await prisma.user.findUnique({
      where: { id: decoded.id },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        businessName: true,
        userType: true,
        verificationTier: true,
        isVerified: true,
        createdAt: true,
      },
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        error: {
          code: 'USER_NOT_FOUND',
          message: 'User not found',
        },
      });
    }

    // Generate new access token
    const newAccessToken = generateAccessToken(user);

    // Set new access token cookie
    res.cookie('access_token', newAccessToken, {
      ...COOKIE_CONFIG,
      maxAge: 60 * 60 * 1000 // 1 hour (matches ACCESS_TOKEN_EXPIRY)
    });

    // Create user response
    const userResponse = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      name: `${user.firstName} ${user.lastName}`,
      businessName: user.businessName,
      role: user.userType,
      userType: user.userType,
      verificationTier: user.verificationTier,
      verified: user.isVerified,
      isVerified: user.isVerified,
      createdAt: user.createdAt,
    };

    logger.info('SSO: Token refreshed successfully:', { userId: user.id });

    return res.json({
      success: true,
      user: userResponse,
    });
  } catch (error) {
    logger.error('SSO: Token refresh error:', error);
    return res.status(401).json({
      success: false,
      error: {
        code: 'INVALID_REFRESH_TOKEN',
        message: 'Invalid refresh token',
      },
    });
  }
});

/**
 * POST /auth/sso-token
 * Issue a short-lived signed token (JWT) that target subdomains can validate
 * and use to set their own HttpOnly cookie for SSO. This endpoint requires an
 * authenticated user (access token) to be present.
 *
 * Body: { target: string }
 */
router.post('/sso-token', async (req: Request, res: Response) => {
  try {
    // Require authenticated access via cookie or Authorization header
  const accessToken = req.headers.authorization?.startsWith('Bearer ') ? req.headers.authorization!.substring(7) : req.cookies.access_token;
    if (!accessToken) {
      return res.status(401).json({ success: false, error: { code: 'NO_TOKEN', message: 'Access token required' } });
    }

    let decoded: any;
    try {
      decoded = jwt.verify(accessToken, JWT_SECRET) as any;
    } catch {
      return res.status(401).json({ success: false, error: { code: 'INVALID_TOKEN', message: 'Invalid access token' } });
    }

    const target = req.body?.target;
    if (!target) {
      return res.status(400).json({ success: false, error: { code: 'MISSING_TARGET', message: 'Target host required' } });
    }

    // Ensure the requesting user has permission to request an SSO token for the target
    const requestingUser = await prisma.user.findUnique({ where: { id: decoded.id }, select: { id: true, userType: true } });
    if (!requestingUser) {
      return res.status(404).json({ success: false, error: { code: 'USER_NOT_FOUND', message: 'User not found' } });
    }

    const targetStr = String(target).toLowerCase();
    const isDashboardTarget = targetStr.includes('dashboard');
    const isAdminTarget = targetStr.includes('admin');

    // Dashboard SSO should only be issued to sellers or users marked as both
    if (isDashboardTarget && !['seller', 'both'].includes(requestingUser.userType)) {
      return res.status(403).json({ success: false, error: { code: 'FORBIDDEN', message: 'Insufficient role to request SSO for dashboard' } });
    } 

    // Admin SSO should only be issued to admin users
    if (isAdminTarget && requestingUser.userType !== 'admin') {
      return res.status(403).json({ success: false, error: { code: 'FORBIDDEN', message: 'Insufficient role to request SSO for admin' } });
    }

    // Create a very short lived SSO token
    const SSO_SECRET = process.env.SSO_SECRET || process.env.JWT_SECRET || 'sso-secret';
    const ssoToken = jwt.sign({ sub: decoded.id, email: decoded.email, aud: target }, SSO_SECRET, { expiresIn: '60s' });

    return res.json({ success: true, token: ssoToken });
  } catch (error) {
    logger.error('SSO token issuance failed:', error);
    return res.status(500).json({ success: false, error: { code: 'SSO_ISSUE_FAILED', message: 'Failed to issue SSO token' } });
  }
});

/**
 * POST /auth/validate-sso
 * Validate an incoming SSO token (short-lived) and ensure the referenced user exists.
 * Body: { token: string }
 * Returns: { success: true, user: { id, email } } on valid token
 */
router.post('/validate-sso', async (req: Request, res: Response) => {
  try {
    const token = req.body?.token;
    if (!token) return res.status(400).json({ success: false, error: { code: 'MISSING_TOKEN', message: 'Token required' } });

    const SSO_SECRET = process.env.SSO_SECRET || process.env.JWT_SECRET || 'sso-secret';
    let payload: any;
    try {
      payload = jwt.verify(token, SSO_SECRET) as any;
    } catch {
      return res.status(401).json({ success: false, error: { code: 'INVALID_SSO', message: 'Invalid or expired SSO token' } });
    }

    // Verify user existence and active status
    const user = await prisma.user.findUnique({ where: { id: payload.sub } });
    if (!user) return res.status(404).json({ success: false, error: { code: 'USER_NOT_FOUND', message: 'User not found' } });

    // Enforce audience-based role constraints: dashboard -> sellers/both, admin -> admin
    const aud = payload.aud && typeof payload.aud === 'string' ? payload.aud.toLowerCase() : '';
    const audIsDashboard = aud.includes('dashboard');
    const audIsAdmin = aud.includes('admin');
    if (audIsDashboard && !['seller', 'both'].includes(user.userType)) {
      return res.status(403).json({ success: false, error: { code: 'FORBIDDEN', message: 'User not authorized for dashboard SSO' } });
    }
    if (audIsAdmin && user.userType !== 'admin') {
      return res.status(403).json({ success: false, error: { code: 'FORBIDDEN', message: 'User not authorized for admin SSO' } });
    }

    // Optionally verify audience claim matches expected host pattern
    if (payload.aud && typeof payload.aud === 'string') {
      // allow if aud equals host or contains it
      // Additional checks can be added here
    }

    return res.json({ success: true, user: { id: user.id, email: user.email } });
  } catch (error) {
    logger.error('SSO validation failed:', error);
    return res.status(500).json({ success: false, error: { code: 'SSO_VALIDATION_FAILED', message: 'Failed to validate SSO token' } });
  }
});

/**
 * GET /auth/me
 * Get current user profile using access token from cookie
 */
router.get('/me', verifyAccessToken, async (req: Request, res: Response) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.authUser!.id },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        businessName: true,
        userType: true,
        verificationTier: true,
        isVerified: true,
        phone: true,
        gstin: true,
        createdAt: true,
      },
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        error: {
          code: 'USER_NOT_FOUND',
          message: 'User not found',
        },
      });
    }

    // Create user response with name field
    const userResponse = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      name: `${user.firstName} ${user.lastName}`,
      businessName: user.businessName,
      role: user.userType,
      userType: user.userType,
      verificationTier: user.verificationTier,
      verified: user.isVerified,
      isVerified: user.isVerified,
      phone: user.phone,
      gstin: user.gstin,
      createdAt: user.createdAt,
    };

    // Generate fresh tokens for localStorage storage (cross-domain compatibility)
    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);

    return res.json({
      success: true,
      user: userResponse,
      accessToken: accessToken,
      refreshToken: refreshToken,
    });
  } catch (error) {
    logger.error('SSO: Get user error:', error);
    return res.status(500).json({
      success: false,
      error: {
        code: 'GET_USER_FAILED',
        message: 'Failed to get user information',
      },
    });
  }
});

/**
 * POST /auth/logout
 * Logout and clear all cookies across subdomains
 */
router.post('/logout', async (req: Request, res: Response) => {
  try {
    const refreshToken = req.cookies.refresh_token;

    // Remove refresh token from storage
    if (refreshToken) {
      refreshTokens.delete(refreshToken);
    }

    // Clear all authentication cookies
    clearAuthCookies(res);

    logger.info('SSO: User logged out successfully');

    return res.json({
      success: true,
      message: 'Logged out successfully',
    });
  } catch (error) {
    logger.error('SSO: Logout error:', error);
    return res.status(500).json({
      success: false,
      error: {
        code: 'LOGOUT_ERROR',
        message: 'Logout failed',
      },
    });
  }
});

/**
 * GET /auth/debug-oauth
 * Return non-sensitive OAuth runtime config to verify deployment correctness.
 * Temporarily made public for debugging - remove in production.
 */
router.get('/debug-oauth', (req: Request, res: Response) => {
  // Temporarily allow without key for debugging
  return res.json({
    success: true,
    google: {
      hasClientId: !!process.env.GOOGLE_CLIENT_ID,
      clientIdSuffix: (process.env.GOOGLE_CLIENT_ID || '').slice(-12),
      fullClientId: process.env.GOOGLE_CLIENT_ID || 'NOT_SET',
      hasClientSecret: !!process.env.GOOGLE_CLIENT_SECRET,
      secretLength: process.env.GOOGLE_CLIENT_SECRET ? process.env.GOOGLE_CLIENT_SECRET.length : 0,
      secretSuffix: process.env.GOOGLE_CLIENT_SECRET ? process.env.GOOGLE_CLIENT_SECRET.slice(-4) : 'NOT_SET',
      callbackURL: process.env.GOOGLE_CALLBACK_URL || 'NOT_SET',
    },
    frontendUrl: process.env.FRONTEND_URL || 'NOT_SET',
    oauthDebug: process.env.OAUTH_DEBUG === 'true',
    nodeEnv: process.env.NODE_ENV,
    ts: new Date().toISOString(),
  });
});/**
 * PUT /auth/profile
 * Update user profile
 */
router.put('/profile', verifyAccessToken, [
  body('firstName').optional().trim().isLength({ min: 1 }).withMessage('First name cannot be empty'),
  body('lastName').optional().trim().isLength({ min: 1 }).withMessage('Last name cannot be empty'),
  body('businessName').optional().trim(),
  body('phone').optional().isMobilePhone('any').withMessage('Invalid phone number'),
  body('gstin').optional().isLength({ min: 15, max: 15 }).withMessage('GSTIN must be 15 characters'),
  handleValidationErrors,
], async (req: Request, res: Response) => {
  try {
    const { firstName, lastName, businessName, phone, gstin } = req.body;

    const user = await prisma.user.update({
      where: { id: req.authUser!.id },
      data: {
        firstName,
        lastName,
        businessName,
        phone,
        gstin,
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        businessName: true,
        userType: true,
        verificationTier: true,
        isVerified: true,
        phone: true,
        gstin: true,
        createdAt: true,
      },
    });

    // Create user response with name field
    const userResponse = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      name: `${user.firstName} ${user.lastName}`,
      businessName: user.businessName,
      role: user.userType,
      userType: user.userType,
      verificationTier: user.verificationTier,
      verified: user.isVerified,
      isVerified: user.isVerified,
      phone: user.phone,
      gstin: user.gstin,
      createdAt: user.createdAt,
    };

    logger.info('SSO: Profile updated successfully:', { userId: user.id });

    return res.json({
      success: true,
      user: userResponse,
      message: 'Profile updated successfully',
    });
  } catch (error) {
    logger.error('SSO: Profile update error:', error);
    return res.status(500).json({
      success: false,
      error: {
        code: 'PROFILE_UPDATE_FAILED',
        message: 'Failed to update profile',
      },
    });
  }
});

// POST /auth/send-otp
router.post('/send-otp', [
  body('identifier').isString().notEmpty(),
  body('type').isIn(['email', 'phone']),
  handleValidationErrors
], async (req: Request, res: Response) => {
  try {
    const { identifier, type } = req.body;

    // Generate and store OTP
    const otp = await OtpService.generateOtp(identifier, type);

    // Try to send via configured notification channel (best-effort)
    (async () => {
      try {
        const channel = type === 'email' ? 'email' : 'sms';
        await notificationService.sendNotification({
          userId: 'system',
          templateName: 'verification_otp',
          channel: channel as any,
          recipient: identifier,
          variables: { otp, identifier }
        });
        logger.info('Sent OTP notification (best-effort) to', { identifier, type });
      } catch (sendErr) {
        logger.warn('Failed to send OTP notification (best-effort):', { error: sendErr && (sendErr as any).message ? (sendErr as any).message : String(sendErr) });
      }
    })();

    // In development return the OTP for convenience
    const responsePayload: any = { success: true, message: 'OTP generated' };
    if (process.env.NODE_ENV === 'development') responsePayload.otp = otp;

    return res.json(responsePayload);
  } catch (error) {
    logger.error('Send OTP failed:', error);
    return res.status(500).json({ success: false, error: { code: 'OTP_GENERATION_FAILED', message: 'Failed to generate OTP' } });
  }
});

// POST /auth/verify-otp
router.post('/verify-otp', [
  body('identifier').isString().notEmpty(),
  body('type').isIn(['email', 'phone']),
  body('otp').isString().isLength({ min: 4, max: 8 }),
  handleValidationErrors
], async (req: Request, res: Response) => {
  try {
    const { identifier, type, otp } = req.body;

    const ok = await OtpService.verifyOtp(identifier, type, otp);
    if (!ok) {
      return res.status(400).json({ success: false, error: { code: 'INVALID_OTP', message: 'Invalid or expired OTP' } });
    }

    // Mark user as verified when identifier maps to a user
    try {
      const user = type === 'email'
        ? await prisma.user.findUnique({ where: { email: identifier } })
        : await prisma.user.findFirst({ where: { phone: identifier } });

      if (user) {
        await prisma.user.update({ where: { id: user.id }, data: { isVerified: true } });
        logger.info('User marked verified via OTP', { userId: user.id, identifier });
      }
    } catch (uErr) {
      logger.warn('Failed to mark user verified after OTP (non-fatal):', uErr);
    }

    return res.json({ success: true, message: 'OTP verified' });
  } catch (error) {
    logger.error('Verify OTP failed:', error);
    return res.status(500).json({ success: false, error: { code: 'OTP_VERIFY_FAILED', message: 'Failed to verify OTP' } });
  }
});

// --- OAuth Routes ---

// Initiate Google OAuth
router.get('/google', (req: Request, res: Response, next: any) => {
  // Always log Google OAuth initiation for debugging
  logger.info('OAuth(Google): Initiating', {
    origin: req.headers.origin,
    state: typeof req.query.state === 'string' ? req.query.state : '',
    host: req.headers.host,
    userAgent: req.headers['user-agent'],
    callbackURL: process.env.GOOGLE_CALLBACK_URL || null,
    timestamp: new Date().toISOString(),
  });
  return passport.authenticate('google', { scope: ['profile', 'email'], session: false })(req, res, next);
});

// Google callback
router.get('/google/callback', (req: Request, res: Response, next: any) => {
  // Always log callback details for debugging
  try {
    const c = typeof req.query.code === 'string' ? req.query.code : '';
    const s = typeof req.query.state === 'string' ? req.query.state : '';
    const details: any = { 
      hasCode: !!c, 
      codeLen: c ? c.length : 0, 
      state: s,
      host: req.headers.host,
      xForwardedHost: req.headers['x-forwarded-host'],
      xForwardedProto: req.headers['x-forwarded-proto'],
      xForwardedFor: req.headers['x-forwarded-for'],
      userAgent: req.headers['user-agent'],
      timestamp: new Date().toISOString(),
    };
    logger.info('OAuth(Google): Callback received', details);
  } catch (e) {
    logger.warn('Failed to log Google callback query', { error: (e as any)?.message || String(e) });
  }
  // If Google sent an error (e.g., access_denied), short-circuit to relay with details
  if (typeof req.query.error === 'string') {
    const state = typeof req.query.state === 'string' ? req.query.state : '';
    const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
    const err = encodeURIComponent(req.query.error);
    const errDesc = encodeURIComponent(String(req.query.error_description || ''));
    const relay = `${frontendBase}/sso-relay.html?error=${err}${errDesc ? '&error_description=' + errDesc : ''}${state ? '&state=' + encodeURIComponent(state) : ''}`;
    return res.redirect(relay);
  }

  passport.authenticate('google', { session: false }, (err: any, result: any) => {
    if (err || !result) {
      // Always log errors for debugging with maximum detail
      logger.error('OAuth(Google): Callback error - detailed', {
        message: err && err.message,
        name: err && err.name,
        status: err && (err.status || err.statusCode),
        statusCode: err && err.statusCode,
        code: err && err.code,
        oauthError: err && err.oauthError,
        oauthResponse: err && err.oauthResponse,
        data: err && err.data,
        stack: err && err.stack ? err.stack.substring(0, 1000) : undefined,
        hasCode: typeof req.query.code === 'string',
        codeLength: typeof req.query.code === 'string' ? req.query.code.length : 0,
        hasResult: !!result,
        errorType: err && err.constructor ? err.constructor.name : typeof err,
        timestamp: new Date().toISOString(),
        // Google specific error fields
        error_description: err && err.error_description,
        error_uri: err && err.error_uri,
        // Raw error for inspection
        rawError: err ? JSON.stringify(err, null, 2).substring(0, 2000) : undefined,
      });
      
      const state = typeof req.query.state === 'string' ? req.query.state : '';
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      const errMsg = err && err.message ? encodeURIComponent(err.message) : '1';
      const relay = `${frontendBase}/sso-relay.html?error=${errMsg}${state ? '&state=' + encodeURIComponent(state) : ''}`;
      return res.redirect(relay);
    }

    try {
      // Set cookies and redirect to frontend relay page for popup flows
      setAuthCookies(res, result.user);

      logger.info('OAuth(Google): Success - cookies set', {
        userId: result.user?.id,
        email: result.user?.email,
        timestamp: new Date().toISOString(),
      });

      const state = typeof req.query.state === 'string' ? req.query.state : '';
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      const relay = `${frontendBase}/sso-relay.html${state ? '?state=' + encodeURIComponent(state) : ''}`;
      return res.redirect(relay);
    } catch (e) {
      logger.error('OAuth(Google): Post-processing failed', {
        error: (e as any)?.message || String(e),
        timestamp: new Date().toISOString(),
      });
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      return res.redirect(`${frontendBase}/sso-relay.html?error=1`);
    }
  })(req, res, next);
});

// Initiate LinkedIn OAuth
router.get('/linkedin', passport.authenticate('linkedin', { scope: ['r_emailaddress', 'r_liteprofile'], session: false }));

// LinkedIn callback
router.get('/linkedin/callback', (req: Request, res: Response, next: any) => {
  passport.authenticate('linkedin', { session: false }, (err: any, result: any) => {
    if (err || !result) {
  logger.error('LinkedIn OAuth callback error', err);
  const state = typeof req.query.state === 'string' ? req.query.state : '';
  const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
  const relay = `${frontendBase}/sso-relay.html?error=1${state ? '&state=' + encodeURIComponent(state) : ''}`;
  return res.redirect(relay);
    }

    try {
      setAuthCookies(res, result.user);
      const state = typeof req.query.state === 'string' ? req.query.state : '';
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      const relay = `${frontendBase}/sso-relay.html${state ? '?state=' + encodeURIComponent(state) : ''}`;
      return res.redirect(relay);
    } catch (e) {
      logger.error('LinkedIn OAuth post-processing failed', e);
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      return res.redirect(`${frontendBase}/sso-relay.html?error=1`);
    }
  })(req, res, next);
});

// Initiate DigiLocker OAuth (redirect to provider)
router.get('/digilocker', (req: Request, res: Response) => {
  const state = typeof req.query.state === 'string' ? req.query.state : undefined;
  const url = DigiLockerService.getAuthorizationUrl(state);
  return res.redirect(url);
});

// DigiLocker callback
router.get('/digilocker/callback', async (req: Request, res: Response) => {
  const code = typeof req.query.code === 'string' ? req.query.code : undefined;
  if (!code) {
    return res.redirect(`${process.env.FRONTEND_URL || '/'}?auth=failed`);
  }

    try {
      const result = await DigiLockerService.handleDigiLockerAuth(code);
      setAuthCookies(res, result.user);
      const state = typeof req.query.state === 'string' ? req.query.state : '';
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      const relay = `${frontendBase}/sso-relay.html${state ? '?state=' + encodeURIComponent(state) : ''}`;
      return res.redirect(relay);
    } catch (e) {
      logger.error('DigiLocker callback failed', e);
      const frontendBase = (process.env.FRONTEND_URL || '/').replace(/\/$/, '');
      return res.redirect(`${frontendBase}/sso-relay.html?error=1`);
    }
});

export default router;